// !!! This is a file automatically generated by hipify!!!
#pragma once

#include <ATen/zoom/ZoomContext.h>

namespace at {
namespace zoom {
namespace solver {

#define HIPSOLVER_GETRF_ARGTYPES(Dtype)  \
    hipsolverDnHandle_t handle, int m, int n, Dtype* dA, int ldda, int* ipiv, int* info

template<class Dtype>
void getrf(HIPSOLVER_GETRF_ARGTYPES(Dtype)) {
  TORCH_CHECK(false, "at::zoom::solver::getrf: not implemented for ", typeid(Dtype).name());
}
template<>
void getrf<float>(HIPSOLVER_GETRF_ARGTYPES(float));
template<>
void getrf<double>(HIPSOLVER_GETRF_ARGTYPES(double));
template<>
void getrf<c10::complex<double>>(HIPSOLVER_GETRF_ARGTYPES(c10::complex<double>));
template<>
void getrf<c10::complex<float>>(HIPSOLVER_GETRF_ARGTYPES(c10::complex<float>));


#define HIPSOLVER_GETRS_ARGTYPES(Dtype)  \
    hipsolverDnHandle_t handle, int n, int nrhs, Dtype* dA, int lda, int* ipiv, Dtype* ret, int ldb, int* info, hipsolverOperation_t trans

template<class Dtype>
void getrs(HIPSOLVER_GETRS_ARGTYPES(Dtype)) {
  TORCH_CHECK(false, "at::zoom::solver::getrs: not implemented for ", typeid(Dtype).name());
}
template<>
void getrs<float>(HIPSOLVER_GETRS_ARGTYPES(float));
template<>
void getrs<double>(HIPSOLVER_GETRS_ARGTYPES(double));
template<>
void getrs<c10::complex<double>>(HIPSOLVER_GETRS_ARGTYPES(c10::complex<double>));
template<>
void getrs<c10::complex<float>>(HIPSOLVER_GETRS_ARGTYPES(c10::complex<float>));

#define HIPSOLVER_SYTRF_BUFFER_ARGTYPES(Dtype) \
  hipsolverDnHandle_t handle, int n, Dtype *A, int lda, int *lwork

template <class Dtype>
void sytrf_bufferSize(HIPSOLVER_SYTRF_BUFFER_ARGTYPES(Dtype)) {
  TORCH_CHECK(
      false,
      "at::zoom::solver::sytrf_bufferSize: not implemented for ",
      typeid(Dtype).name());
}
template <>
void sytrf_bufferSize<float>(HIPSOLVER_SYTRF_BUFFER_ARGTYPES(float));
template <>
void sytrf_bufferSize<double>(HIPSOLVER_SYTRF_BUFFER_ARGTYPES(double));
template <>
void sytrf_bufferSize<c10::complex<double>>(
    HIPSOLVER_SYTRF_BUFFER_ARGTYPES(c10::complex<double>));
template <>
void sytrf_bufferSize<c10::complex<float>>(
    HIPSOLVER_SYTRF_BUFFER_ARGTYPES(c10::complex<float>));

#define HIPSOLVER_SYTRF_ARGTYPES(Dtype)                                      \
  hipsolverDnHandle_t handle, hipsolverFillMode_t uplo, int n, Dtype *A, int lda, \
      int *ipiv, Dtype *work, int lwork, int *devInfo

template <class Dtype>
void sytrf(HIPSOLVER_SYTRF_ARGTYPES(Dtype)) {
  TORCH_CHECK(
      false,
      "at::zoom::solver::sytrf: not implemented for ",
      typeid(Dtype).name());
}
template <>
void sytrf<float>(HIPSOLVER_SYTRF_ARGTYPES(float));
template <>
void sytrf<double>(HIPSOLVER_SYTRF_ARGTYPES(double));
template <>
void sytrf<c10::complex<double>>(
    HIPSOLVER_SYTRF_ARGTYPES(c10::complex<double>));
template <>
void sytrf<c10::complex<float>>(HIPSOLVER_SYTRF_ARGTYPES(c10::complex<float>));

#define HIPSOLVER_GESVD_BUFFERSIZE_ARGTYPES()  \
    hipsolverDnHandle_t handle, int m, int n, int *lwork

template<class Dtype>
void gesvd_buffersize(HIPSOLVER_GESVD_BUFFERSIZE_ARGTYPES()) {
  TORCH_CHECK(false, "at::zoom::solver::gesvd_buffersize: not implemented for ", typeid(Dtype).name());
}
template<>
void gesvd_buffersize<float>(HIPSOLVER_GESVD_BUFFERSIZE_ARGTYPES());
template<>
void gesvd_buffersize<double>(HIPSOLVER_GESVD_BUFFERSIZE_ARGTYPES());
template<>
void gesvd_buffersize<c10::complex<float>>(HIPSOLVER_GESVD_BUFFERSIZE_ARGTYPES());
template<>
void gesvd_buffersize<c10::complex<double>>(HIPSOLVER_GESVD_BUFFERSIZE_ARGTYPES());


#define HIPSOLVER_GESVD_ARGTYPES(Dtype, Vtype)  \
    hipsolverDnHandle_t handle, signed char jobu, signed char jobvt, int m, int n, Dtype *A, int lda, \
    Vtype *S, Dtype *U, int ldu, Dtype *VT, int ldvt, Dtype *work, int lwork, Vtype *rwork, int *info

template<class Dtype, class Vtype>
void gesvd(HIPSOLVER_GESVD_ARGTYPES(Dtype, Vtype)) {
  TORCH_CHECK(false, "at::zoom::solver::gesvd: not implemented for ", typeid(Dtype).name());
}
template<>
void gesvd<float>(HIPSOLVER_GESVD_ARGTYPES(float, float));
template<>
void gesvd<double>(HIPSOLVER_GESVD_ARGTYPES(double, double));
template<>
void gesvd<c10::complex<float>>(HIPSOLVER_GESVD_ARGTYPES(c10::complex<float>, float));
template<>
void gesvd<c10::complex<double>>(HIPSOLVER_GESVD_ARGTYPES(c10::complex<double>, double));


#define HIPSOLVER_GESVDJ_BUFFERSIZE_ARGTYPES(Dtype, Vtype)  \
    hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, int econ, int m, int n, Dtype *A, int lda, Vtype *S, \
    Dtype *U, int ldu, Dtype *V, int ldv, int *lwork, hipsolverGesvdjInfo_t params

template<class Dtype, class Vtype>
void gesvdj_buffersize(HIPSOLVER_GESVDJ_BUFFERSIZE_ARGTYPES(Dtype, Vtype)) {
  TORCH_INTERNAL_ASSERT(false, "at::zoom::solver::gesvdj_buffersize: not implemented for ", typeid(Dtype).name());
}
template<>
void gesvdj_buffersize<float>(HIPSOLVER_GESVDJ_BUFFERSIZE_ARGTYPES(float, float));
template<>
void gesvdj_buffersize<double>(HIPSOLVER_GESVDJ_BUFFERSIZE_ARGTYPES(double, double));
template<>
void gesvdj_buffersize<c10::complex<float>>(HIPSOLVER_GESVDJ_BUFFERSIZE_ARGTYPES(c10::complex<float>, float));
template<>
void gesvdj_buffersize<c10::complex<double>>(HIPSOLVER_GESVDJ_BUFFERSIZE_ARGTYPES(c10::complex<double>, double));


#define HIPSOLVER_GESVDJ_ARGTYPES(Dtype, Vtype)  \
    hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, int econ, int m, int n, Dtype* A, int lda, Vtype* S, Dtype* U, \
    int ldu, Dtype* V, int ldv, Dtype* work, int lwork, int *info, hipsolverGesvdjInfo_t params

template<class Dtype, class Vtype>
void gesvdj(HIPSOLVER_GESVDJ_ARGTYPES(Dtype, Vtype)) {
  TORCH_INTERNAL_ASSERT(false, "at::zoom::solver::gesvdj: not implemented for ", typeid(Dtype).name());
}
template<>
void gesvdj<float>(HIPSOLVER_GESVDJ_ARGTYPES(float, float));
template<>
void gesvdj<double>(HIPSOLVER_GESVDJ_ARGTYPES(double, double));
template<>
void gesvdj<c10::complex<float>>(HIPSOLVER_GESVDJ_ARGTYPES(c10::complex<float>, float));
template<>
void gesvdj<c10::complex<double>>(HIPSOLVER_GESVDJ_ARGTYPES(c10::complex<double>, double));


#define HIPSOLVER_GESVDJ_BATCHED_ARGTYPES(Dtype, Vtype)  \
    hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, int m, int n, Dtype* A, int lda, Vtype* S, Dtype* U, \
    int ldu, Dtype *V, int ldv, int *info, hipsolverGesvdjInfo_t params, int batchSize

template<class Dtype, class Vtype>
void gesvdjBatched(HIPSOLVER_GESVDJ_BATCHED_ARGTYPES(Dtype, Vtype)) {
  TORCH_INTERNAL_ASSERT(false, "at::zoom::solver::gesvdj: not implemented for ", typeid(Dtype).name());
}
template<>
void gesvdjBatched<float>(HIPSOLVER_GESVDJ_BATCHED_ARGTYPES(float, float));
template<>
void gesvdjBatched<double>(HIPSOLVER_GESVDJ_BATCHED_ARGTYPES(double, double));
template<>
void gesvdjBatched<c10::complex<float>>(HIPSOLVER_GESVDJ_BATCHED_ARGTYPES(c10::complex<float>, float));
template<>
void gesvdjBatched<c10::complex<double>>(HIPSOLVER_GESVDJ_BATCHED_ARGTYPES(c10::complex<double>, double));

#define HIPSOLVER_GESVDA_STRIDED_BATCHED_BUFFERSIZE_ARGTYPES(Dtype, Vtype)  \
    hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, int rank, int m, int n, Dtype *A, int lda, long long int strideA, \
    Vtype *S, long long int strideS, Dtype *U, int ldu, long long int strideU, Dtype *V, int ldv, long long int strideV, \
    int *lwork, int batchSize

template<class Dtype, class Vtype>
void gesvdaStridedBatched_buffersize(HIPSOLVER_GESVDA_STRIDED_BATCHED_BUFFERSIZE_ARGTYPES(Dtype, Vtype)) {
  TORCH_INTERNAL_ASSERT(false, "at::zoom::solver::gesvdaStridedBatched_buffersize: not implemented for ", typeid(Dtype).name());
}
template<>
void gesvdaStridedBatched_buffersize<float>(HIPSOLVER_GESVDA_STRIDED_BATCHED_BUFFERSIZE_ARGTYPES(float, float));
template<>
void gesvdaStridedBatched_buffersize<double>(HIPSOLVER_GESVDA_STRIDED_BATCHED_BUFFERSIZE_ARGTYPES(double, double));
template<>
void gesvdaStridedBatched_buffersize<c10::complex<float>>(HIPSOLVER_GESVDA_STRIDED_BATCHED_BUFFERSIZE_ARGTYPES(c10::complex<float>, float));
template<>
void gesvdaStridedBatched_buffersize<c10::complex<double>>(HIPSOLVER_GESVDA_STRIDED_BATCHED_BUFFERSIZE_ARGTYPES(c10::complex<double>, double));


#define HIPSOLVER_GESVDA_STRIDED_BATCHED_ARGTYPES(Dtype, Vtype)  \
    hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, int rank, int m, int n, Dtype *A, int lda, long long int strideA, \
    Vtype *S, long long int strideS, Dtype *U, int ldu, long long int strideU, Dtype *V, int ldv, long long int strideV, \
    Dtype *work, int lwork, int *info, double *h_R_nrmF, int batchSize
// h_R_nrmF is always double, regardless of input Dtype.

template<class Dtype, class Vtype>
void gesvdaStridedBatched(HIPSOLVER_GESVDA_STRIDED_BATCHED_ARGTYPES(Dtype, Vtype)) {
  TORCH_INTERNAL_ASSERT(false, "at::zoom::solver::gesvdaStridedBatched: not implemented for ", typeid(Dtype).name());
}
template<>
void gesvdaStridedBatched<float>(HIPSOLVER_GESVDA_STRIDED_BATCHED_ARGTYPES(float, float));
template<>
void gesvdaStridedBatched<double>(HIPSOLVER_GESVDA_STRIDED_BATCHED_ARGTYPES(double, double));
template<>
void gesvdaStridedBatched<c10::complex<float>>(HIPSOLVER_GESVDA_STRIDED_BATCHED_ARGTYPES(c10::complex<float>, float));
template<>
void gesvdaStridedBatched<c10::complex<double>>(HIPSOLVER_GESVDA_STRIDED_BATCHED_ARGTYPES(c10::complex<double>, double));


#define HIPSOLVER_POTRF_ARGTYPES(Dtype)  \
    hipsolverDnHandle_t handle, hipsolverFillMode_t uplo, int n, Dtype* A, int lda, Dtype* work, int lwork, int* info

template<class Dtype>
void potrf(HIPSOLVER_POTRF_ARGTYPES(Dtype)) {
  TORCH_INTERNAL_ASSERT(false, "at::zoom::solver::potrf: not implemented for ", typeid(Dtype).name());
}
template<>
void potrf<float>(HIPSOLVER_POTRF_ARGTYPES(float));
template<>
void potrf<double>(HIPSOLVER_POTRF_ARGTYPES(double));
template<>
void potrf<c10::complex<float>>(HIPSOLVER_POTRF_ARGTYPES(c10::complex<float>));
template<>
void potrf<c10::complex<double>>(HIPSOLVER_POTRF_ARGTYPES(c10::complex<double>));


#define HIPSOLVER_POTRF_BUFFERSIZE_ARGTYPES(Dtype)  \
    hipsolverDnHandle_t handle, hipsolverFillMode_t uplo, int n, Dtype* A, int lda, int* lwork

template<class Dtype>
void potrf_buffersize(HIPSOLVER_POTRF_BUFFERSIZE_ARGTYPES(Dtype)) {
  TORCH_INTERNAL_ASSERT(false, "at::zoom::solver::potrf_buffersize: not implemented for ", typeid(Dtype).name());
}
template<>
void potrf_buffersize<float>(HIPSOLVER_POTRF_BUFFERSIZE_ARGTYPES(float));
template<>
void potrf_buffersize<double>(HIPSOLVER_POTRF_BUFFERSIZE_ARGTYPES(double));
template<>
void potrf_buffersize<c10::complex<float>>(HIPSOLVER_POTRF_BUFFERSIZE_ARGTYPES(c10::complex<float>));
template<>
void potrf_buffersize<c10::complex<double>>(HIPSOLVER_POTRF_BUFFERSIZE_ARGTYPES(c10::complex<double>));


#define HIPSOLVER_POTRF_BATCHED_ARGTYPES(Dtype)  \
    hipsolverDnHandle_t handle, hipsolverFillMode_t uplo, int n, Dtype** A, int lda, int* info, int batchSize

template<class Dtype>
void potrfBatched(HIPSOLVER_POTRF_BATCHED_ARGTYPES(Dtype)) {
  TORCH_INTERNAL_ASSERT(false, "at::zoom::solver::potrfBatched: not implemented for ", typeid(Dtype).name());
}
template<>
void potrfBatched<float>(HIPSOLVER_POTRF_BATCHED_ARGTYPES(float));
template<>
void potrfBatched<double>(HIPSOLVER_POTRF_BATCHED_ARGTYPES(double));
template<>
void potrfBatched<c10::complex<float>>(HIPSOLVER_POTRF_BATCHED_ARGTYPES(c10::complex<float>));
template<>
void potrfBatched<c10::complex<double>>(HIPSOLVER_POTRF_BATCHED_ARGTYPES(c10::complex<double>));

#define HIPSOLVER_GEQRF_BUFFERSIZE_ARGTYPES(scalar_t) \
  hipsolverDnHandle_t handle, int m, int n, scalar_t *A, int lda, int *lwork

template <class scalar_t>
void geqrf_bufferSize(HIPSOLVER_GEQRF_BUFFERSIZE_ARGTYPES(scalar_t)) {
  TORCH_CHECK(
      false,
      "at::zoom::solver::geqrf_bufferSize: not implemented for ",
      typeid(scalar_t).name());
}
template <>
void geqrf_bufferSize<float>(HIPSOLVER_GEQRF_BUFFERSIZE_ARGTYPES(float));
template <>
void geqrf_bufferSize<double>(HIPSOLVER_GEQRF_BUFFERSIZE_ARGTYPES(double));
template <>
void geqrf_bufferSize<c10::complex<float>>(
    HIPSOLVER_GEQRF_BUFFERSIZE_ARGTYPES(c10::complex<float>));
template <>
void geqrf_bufferSize<c10::complex<double>>(
    HIPSOLVER_GEQRF_BUFFERSIZE_ARGTYPES(c10::complex<double>));

#define HIPSOLVER_GEQRF_ARGTYPES(scalar_t)                      \
  hipsolverDnHandle_t handle, int m, int n, scalar_t *A, int lda, \
      scalar_t *tau, scalar_t *work, int lwork, int *devInfo

template <class scalar_t>
void geqrf(HIPSOLVER_GEQRF_ARGTYPES(scalar_t)) {
  TORCH_CHECK(
      false,
      "at::zoom::solver::geqrf: not implemented for ",
      typeid(scalar_t).name());
}
template <>
void geqrf<float>(HIPSOLVER_GEQRF_ARGTYPES(float));
template <>
void geqrf<double>(HIPSOLVER_GEQRF_ARGTYPES(double));
template <>
void geqrf<c10::complex<float>>(HIPSOLVER_GEQRF_ARGTYPES(c10::complex<float>));
template <>
void geqrf<c10::complex<double>>(
    HIPSOLVER_GEQRF_ARGTYPES(c10::complex<double>));

#define HIPSOLVER_POTRS_ARGTYPES(Dtype)  \
    hipsolverDnHandle_t handle, hipsolverFillMode_t uplo, int n, int nrhs, const Dtype *A, int lda, Dtype *B, int ldb, int *devInfo

template<class Dtype>
void potrs(HIPSOLVER_POTRS_ARGTYPES(Dtype)) {
  TORCH_INTERNAL_ASSERT(false, "at::zoom::solver::potrs: not implemented for ", typeid(Dtype).name());
}
template<>
void potrs<float>(HIPSOLVER_POTRS_ARGTYPES(float));
template<>
void potrs<double>(HIPSOLVER_POTRS_ARGTYPES(double));
template<>
void potrs<c10::complex<float>>(HIPSOLVER_POTRS_ARGTYPES(c10::complex<float>));
template<>
void potrs<c10::complex<double>>(HIPSOLVER_POTRS_ARGTYPES(c10::complex<double>));


#define HIPSOLVER_POTRS_BATCHED_ARGTYPES(Dtype)  \
    hipsolverDnHandle_t handle, hipsolverFillMode_t uplo, int n, int nrhs, Dtype *Aarray[], int lda, Dtype *Barray[], int ldb, int *info, int batchSize

template<class Dtype>
void potrsBatched(HIPSOLVER_POTRS_BATCHED_ARGTYPES(Dtype)) {
  TORCH_INTERNAL_ASSERT(false, "at::zoom::solver::potrsBatched: not implemented for ", typeid(Dtype).name());
}
template<>
void potrsBatched<float>(HIPSOLVER_POTRS_BATCHED_ARGTYPES(float));
template<>
void potrsBatched<double>(HIPSOLVER_POTRS_BATCHED_ARGTYPES(double));
template<>
void potrsBatched<c10::complex<float>>(HIPSOLVER_POTRS_BATCHED_ARGTYPES(c10::complex<float>));
template<>
void potrsBatched<c10::complex<double>>(HIPSOLVER_POTRS_BATCHED_ARGTYPES(c10::complex<double>));


#define HIPSOLVER_ORGQR_BUFFERSIZE_ARGTYPES(Dtype)                        \
  hipsolverDnHandle_t handle, int m, int n, int k, const Dtype *A, int lda, \
      const Dtype *tau, int *lwork

template <class Dtype>
void orgqr_buffersize(HIPSOLVER_ORGQR_BUFFERSIZE_ARGTYPES(Dtype)) {
  TORCH_CHECK(
      false,
      "at::zoom::solver::orgqr_buffersize: not implemented for ",
      typeid(Dtype).name());
}
template <>
void orgqr_buffersize<float>(HIPSOLVER_ORGQR_BUFFERSIZE_ARGTYPES(float));
template <>
void orgqr_buffersize<double>(HIPSOLVER_ORGQR_BUFFERSIZE_ARGTYPES(double));
template <>
void orgqr_buffersize<c10::complex<float>>(HIPSOLVER_ORGQR_BUFFERSIZE_ARGTYPES(c10::complex<float>));
template <>
void orgqr_buffersize<c10::complex<double>>(HIPSOLVER_ORGQR_BUFFERSIZE_ARGTYPES(c10::complex<double>));


#define HIPSOLVER_ORGQR_ARGTYPES(Dtype)                             \
  hipsolverDnHandle_t handle, int m, int n, int k, Dtype *A, int lda, \
      const Dtype *tau, Dtype *work, int lwork, int *devInfo

template <class Dtype>
void orgqr(HIPSOLVER_ORGQR_ARGTYPES(Dtype)) {
  TORCH_CHECK(
      false,
      "at::zoom::solver::orgqr: not implemented for ",
      typeid(Dtype).name());
}
template <>
void orgqr<float>(HIPSOLVER_ORGQR_ARGTYPES(float));
template <>
void orgqr<double>(HIPSOLVER_ORGQR_ARGTYPES(double));
template <>
void orgqr<c10::complex<float>>(HIPSOLVER_ORGQR_ARGTYPES(c10::complex<float>));
template <>
void orgqr<c10::complex<double>>(HIPSOLVER_ORGQR_ARGTYPES(c10::complex<double>));

#define HIPSOLVER_ORMQR_BUFFERSIZE_ARGTYPES(Dtype)                          \
  hipsolverDnHandle_t handle, hipsolverSideMode_t side, hipsolverOperation_t trans, \
      int m, int n, int k, const Dtype *A, int lda, const Dtype *tau,        \
      const Dtype *C, int ldc, int *lwork

template <class Dtype>
void ormqr_bufferSize(HIPSOLVER_ORMQR_BUFFERSIZE_ARGTYPES(Dtype)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::ormqr_bufferSize: not implemented for ",
      typeid(Dtype).name());
}
template <>
void ormqr_bufferSize<float>(HIPSOLVER_ORMQR_BUFFERSIZE_ARGTYPES(float));
template <>
void ormqr_bufferSize<double>(HIPSOLVER_ORMQR_BUFFERSIZE_ARGTYPES(double));
template <>
void ormqr_bufferSize<c10::complex<float>>(
    HIPSOLVER_ORMQR_BUFFERSIZE_ARGTYPES(c10::complex<float>));
template <>
void ormqr_bufferSize<c10::complex<double>>(
    HIPSOLVER_ORMQR_BUFFERSIZE_ARGTYPES(c10::complex<double>));

#define HIPSOLVER_ORMQR_ARGTYPES(Dtype)                                     \
  hipsolverDnHandle_t handle, hipsolverSideMode_t side, hipsolverOperation_t trans, \
      int m, int n, int k, const Dtype *A, int lda, const Dtype *tau, Dtype *C,    \
      int ldc, Dtype *work, int lwork, int *devInfo

template <class Dtype>
void ormqr(HIPSOLVER_ORMQR_ARGTYPES(Dtype)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::ormqr: not implemented for ",
      typeid(Dtype).name());
}
template <>
void ormqr<float>(HIPSOLVER_ORMQR_ARGTYPES(float));
template <>
void ormqr<double>(HIPSOLVER_ORMQR_ARGTYPES(double));
template <>
void ormqr<c10::complex<float>>(HIPSOLVER_ORMQR_ARGTYPES(c10::complex<float>));
template <>
void ormqr<c10::complex<double>>(
    HIPSOLVER_ORMQR_ARGTYPES(c10::complex<double>));

#ifdef USE_CUSOLVER_64_BIT

template<class Dtype>
hipDataType get_hipsolver_datatype() {
  TORCH_CHECK(false, "cusolver doesn't support data type ", typeid(Dtype).name());
}
template<> hipDataType get_hipsolver_datatype<float>();
template<> hipDataType get_hipsolver_datatype<double>();
template<> hipDataType get_hipsolver_datatype<c10::complex<float>>();
template<> hipDataType get_hipsolver_datatype<c10::complex<double>>();

void xpotrf_buffersize(
    hipsolverDnHandle_t handle, hipsolverDnParams_t params, hipsolverFillMode_t uplo, int64_t n, hipDataType dataTypeA, const void *A,
    int64_t lda, hipDataType computeType, size_t *workspaceInBytesOnDevice, size_t *workspaceInBytesOnHost);

void xpotrf(
    hipsolverDnHandle_t handle, hipsolverDnParams_t params, hipsolverFillMode_t uplo, int64_t n, hipDataType dataTypeA, void *A,
    int64_t lda, hipDataType computeType, void *bufferOnDevice, size_t workspaceInBytesOnDevice, void *bufferOnHost, size_t workspaceInBytesOnHost,
    int *info);

void xpotrs(
    hipsolverDnHandle_t handle, hipsolverDnParams_t params, hipsolverFillMode_t uplo, int64_t n, int64_t nrhs, hipDataType dataTypeA, const void *A,
    int64_t lda, hipDataType dataTypeB, void *B, int64_t ldb, int *info);

#endif // USE_CUSOLVER_64_BIT

#define HIPSOLVER_SYEVD_BUFFERSIZE_ARGTYPES(scalar_t, value_t)             \
  hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, hipsolverFillMode_t uplo, \
      int n, const scalar_t *A, int lda, const value_t *W, int *lwork

template <class scalar_t, class value_t = scalar_t>
void syevd_bufferSize(HIPSOLVER_SYEVD_BUFFERSIZE_ARGTYPES(scalar_t, value_t)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::syevd_bufferSize: not implemented for ",
      typeid(scalar_t).name());
}

template <>
void syevd_bufferSize<float>(
    HIPSOLVER_SYEVD_BUFFERSIZE_ARGTYPES(float, float));
template <>
void syevd_bufferSize<double>(
    HIPSOLVER_SYEVD_BUFFERSIZE_ARGTYPES(double, double));
template <>
void syevd_bufferSize<c10::complex<float>, float>(
    HIPSOLVER_SYEVD_BUFFERSIZE_ARGTYPES(c10::complex<float>, float));
template <>
void syevd_bufferSize<c10::complex<double>, double>(
    HIPSOLVER_SYEVD_BUFFERSIZE_ARGTYPES(c10::complex<double>, double));

#define HIPSOLVER_SYEVD_ARGTYPES(scalar_t, value_t)                        \
  hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, hipsolverFillMode_t uplo, \
      int n, scalar_t *A, int lda, value_t *W, scalar_t *work, int lwork,   \
      int *info

template <class scalar_t, class value_t = scalar_t>
void syevd(HIPSOLVER_SYEVD_ARGTYPES(scalar_t, value_t)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::syevd: not implemented for ",
      typeid(scalar_t).name());
}

template <>
void syevd<float>(HIPSOLVER_SYEVD_ARGTYPES(float, float));
template <>
void syevd<double>(HIPSOLVER_SYEVD_ARGTYPES(double, double));
template <>
void syevd<c10::complex<float>, float>(
    HIPSOLVER_SYEVD_ARGTYPES(c10::complex<float>, float));
template <>
void syevd<c10::complex<double>, double>(
    HIPSOLVER_SYEVD_ARGTYPES(c10::complex<double>, double));

#define HIPSOLVER_SYEVJ_BUFFERSIZE_ARGTYPES(scalar_t, value_t)             \
  hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, hipsolverFillMode_t uplo, \
      int n, const scalar_t *A, int lda, const value_t *W, int *lwork,      \
      hipsolverSyevjInfo_t params

template <class scalar_t, class value_t = scalar_t>
void syevj_bufferSize(HIPSOLVER_SYEVJ_BUFFERSIZE_ARGTYPES(scalar_t, value_t)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::syevj_bufferSize: not implemented for ",
      typeid(scalar_t).name());
}

template <>
void syevj_bufferSize<float>(
    HIPSOLVER_SYEVJ_BUFFERSIZE_ARGTYPES(float, float));
template <>
void syevj_bufferSize<double>(
    HIPSOLVER_SYEVJ_BUFFERSIZE_ARGTYPES(double, double));
template <>
void syevj_bufferSize<c10::complex<float>, float>(
    HIPSOLVER_SYEVJ_BUFFERSIZE_ARGTYPES(c10::complex<float>, float));
template <>
void syevj_bufferSize<c10::complex<double>, double>(
    HIPSOLVER_SYEVJ_BUFFERSIZE_ARGTYPES(c10::complex<double>, double));

#define HIPSOLVER_SYEVJ_ARGTYPES(scalar_t, value_t)                        \
  hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, hipsolverFillMode_t uplo, \
      int n, scalar_t *A, int lda, value_t *W, scalar_t *work, int lwork,   \
      int *info, hipsolverSyevjInfo_t params

template <class scalar_t, class value_t = scalar_t>
void syevj(HIPSOLVER_SYEVJ_ARGTYPES(scalar_t, value_t)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::syevj: not implemented for ",
      typeid(scalar_t).name());
}

template <>
void syevj<float>(HIPSOLVER_SYEVJ_ARGTYPES(float, float));
template <>
void syevj<double>(HIPSOLVER_SYEVJ_ARGTYPES(double, double));
template <>
void syevj<c10::complex<float>, float>(
    HIPSOLVER_SYEVJ_ARGTYPES(c10::complex<float>, float));
template <>
void syevj<c10::complex<double>, double>(
    HIPSOLVER_SYEVJ_ARGTYPES(c10::complex<double>, double));

#define HIPSOLVER_SYEVJ_BATCHED_BUFFERSIZE_ARGTYPES(scalar_t, value_t)     \
  hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, hipsolverFillMode_t uplo, \
      int n, const scalar_t *A, int lda, const value_t *W, int *lwork,      \
      hipsolverSyevjInfo_t params, int batchsize

template <class scalar_t, class value_t = scalar_t>
void syevjBatched_bufferSize(
    HIPSOLVER_SYEVJ_BATCHED_BUFFERSIZE_ARGTYPES(scalar_t, value_t)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::syevjBatched_bufferSize: not implemented for ",
      typeid(scalar_t).name());
}

template <>
void syevjBatched_bufferSize<float>(
    HIPSOLVER_SYEVJ_BATCHED_BUFFERSIZE_ARGTYPES(float, float));
template <>
void syevjBatched_bufferSize<double>(
    HIPSOLVER_SYEVJ_BATCHED_BUFFERSIZE_ARGTYPES(double, double));
template <>
void syevjBatched_bufferSize<c10::complex<float>, float>(
    HIPSOLVER_SYEVJ_BATCHED_BUFFERSIZE_ARGTYPES(c10::complex<float>, float));
template <>
void syevjBatched_bufferSize<c10::complex<double>, double>(
    HIPSOLVER_SYEVJ_BATCHED_BUFFERSIZE_ARGTYPES(c10::complex<double>, double));

#define HIPSOLVER_SYEVJ_BATCHED_ARGTYPES(scalar_t, value_t)                \
  hipsolverDnHandle_t handle, hipsolverEigMode_t jobz, hipsolverFillMode_t uplo, \
      int n, scalar_t *A, int lda, value_t *W, scalar_t *work, int lwork,   \
      int *info, hipsolverSyevjInfo_t params, int batchsize

template <class scalar_t, class value_t = scalar_t>
void syevjBatched(HIPSOLVER_SYEVJ_BATCHED_ARGTYPES(scalar_t, value_t)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::syevjBatched: not implemented for ",
      typeid(scalar_t).name());
}

template <>
void syevjBatched<float>(HIPSOLVER_SYEVJ_BATCHED_ARGTYPES(float, float));
template <>
void syevjBatched<double>(HIPSOLVER_SYEVJ_BATCHED_ARGTYPES(double, double));
template <>
void syevjBatched<c10::complex<float>, float>(
    HIPSOLVER_SYEVJ_BATCHED_ARGTYPES(c10::complex<float>, float));
template <>
void syevjBatched<c10::complex<double>, double>(
    HIPSOLVER_SYEVJ_BATCHED_ARGTYPES(c10::complex<double>, double));

#ifdef USE_CUSOLVER_64_BIT

#define HIPSOLVER_XGEQRF_BUFFERSIZE_ARGTYPES(scalar_t)                       \
  hipsolverDnHandle_t handle, hipsolverDnParams_t params, int64_t m, int64_t n, \
      const scalar_t *A, int64_t lda, const scalar_t *tau,                    \
      size_t *workspaceInBytesOnDevice, size_t *workspaceInBytesOnHost

template <class scalar_t>
void xgeqrf_bufferSize(HIPSOLVER_XGEQRF_BUFFERSIZE_ARGTYPES(scalar_t)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::xgeqrf_bufferSize: not implemented for ",
      typeid(scalar_t).name());
}

template <>
void xgeqrf_bufferSize<float>(HIPSOLVER_XGEQRF_BUFFERSIZE_ARGTYPES(float));
template <>
void xgeqrf_bufferSize<double>(HIPSOLVER_XGEQRF_BUFFERSIZE_ARGTYPES(double));
template <>
void xgeqrf_bufferSize<c10::complex<float>>(
    HIPSOLVER_XGEQRF_BUFFERSIZE_ARGTYPES(c10::complex<float>));
template <>
void xgeqrf_bufferSize<c10::complex<double>>(
    HIPSOLVER_XGEQRF_BUFFERSIZE_ARGTYPES(c10::complex<double>));

#define HIPSOLVER_XGEQRF_ARGTYPES(scalar_t)                                  \
  hipsolverDnHandle_t handle, hipsolverDnParams_t params, int64_t m, int64_t n, \
      scalar_t *A, int64_t lda, scalar_t *tau, scalar_t *bufferOnDevice,      \
      size_t workspaceInBytesOnDevice, scalar_t *bufferOnHost,                \
      size_t workspaceInBytesOnHost, int *info

template <class scalar_t>
void xgeqrf(HIPSOLVER_XGEQRF_ARGTYPES(scalar_t)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::xgeqrf: not implemented for ",
      typeid(scalar_t).name());
}

template <>
void xgeqrf<float>(HIPSOLVER_XGEQRF_ARGTYPES(float));
template <>
void xgeqrf<double>(HIPSOLVER_XGEQRF_ARGTYPES(double));
template <>
void xgeqrf<c10::complex<float>>(
    HIPSOLVER_XGEQRF_ARGTYPES(c10::complex<float>));
template <>
void xgeqrf<c10::complex<double>>(
    HIPSOLVER_XGEQRF_ARGTYPES(c10::complex<double>));

#define HIPSOLVER_XSYEVD_BUFFERSIZE_ARGTYPES(scalar_t, value_t) \
  hipsolverDnHandle_t handle, hipsolverDnParams_t params,          \
      hipsolverEigMode_t jobz, hipsolverFillMode_t uplo, int64_t n,  \
      const scalar_t *A, int64_t lda, const value_t *W,          \
      size_t *workspaceInBytesOnDevice, size_t *workspaceInBytesOnHost

template <class scalar_t, class value_t = scalar_t>
void xsyevd_bufferSize(
    HIPSOLVER_XSYEVD_BUFFERSIZE_ARGTYPES(scalar_t, value_t)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::xsyevd_bufferSize: not implemented for ",
      typeid(scalar_t).name());
}

template <>
void xsyevd_bufferSize<float>(
    HIPSOLVER_XSYEVD_BUFFERSIZE_ARGTYPES(float, float));
template <>
void xsyevd_bufferSize<double>(
    HIPSOLVER_XSYEVD_BUFFERSIZE_ARGTYPES(double, double));
template <>
void xsyevd_bufferSize<c10::complex<float>, float>(
    HIPSOLVER_XSYEVD_BUFFERSIZE_ARGTYPES(c10::complex<float>, float));
template <>
void xsyevd_bufferSize<c10::complex<double>, double>(
    HIPSOLVER_XSYEVD_BUFFERSIZE_ARGTYPES(c10::complex<double>, double));

#define HIPSOLVER_XSYEVD_ARGTYPES(scalar_t, value_t)                        \
  hipsolverDnHandle_t handle, hipsolverDnParams_t params,                      \
      hipsolverEigMode_t jobz, hipsolverFillMode_t uplo, int64_t n, scalar_t *A, \
      int64_t lda, value_t *W, scalar_t *bufferOnDevice,                     \
      size_t workspaceInBytesOnDevice, scalar_t *bufferOnHost,               \
      size_t workspaceInBytesOnHost, int *info

template <class scalar_t, class value_t = scalar_t>
void xsyevd(HIPSOLVER_XSYEVD_ARGTYPES(scalar_t, value_t)) {
  TORCH_INTERNAL_ASSERT(
      false,
      "at::zoom::solver::xsyevd: not implemented for ",
      typeid(scalar_t).name());
}

template <>
void xsyevd<float>(HIPSOLVER_XSYEVD_ARGTYPES(float, float));
template <>
void xsyevd<double>(HIPSOLVER_XSYEVD_ARGTYPES(double, double));
template <>
void xsyevd<c10::complex<float>, float>(
    HIPSOLVER_XSYEVD_ARGTYPES(c10::complex<float>, float));
template <>
void xsyevd<c10::complex<double>, double>(
    HIPSOLVER_XSYEVD_ARGTYPES(c10::complex<double>, double));

#endif // USE_CUSOLVER_64_BIT

} // namespace solver
} // namespace zoom
} // namespace at
